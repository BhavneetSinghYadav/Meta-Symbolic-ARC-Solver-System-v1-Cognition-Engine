from __future__ import annotations

"""Repeat tiling transformation utilities."""

from typing import List

import os
from arc_solver.src.configs.defaults import MAX_REPEAT_DIFF, ENABLE_COMPOSITE_REPEAT

from arc_solver.src.core.grid import Grid
from arc_solver.src.utils.patterns import detect_replace_map
from arc_solver.src.symbolic.vocabulary import (
    Symbol,
    SymbolType,
    SymbolicRule,
    Transformation,
    TransformationNature,
    TransformationType,
)
from arc_solver.src.symbolic.rule_language import CompositeRule


def repeat_tile(grid: Grid, kx: int, ky: int) -> Grid:
    """Return ``grid`` tiled ``kx`` times horizontally and ``ky`` times vertically."""
    if kx <= 0 or ky <= 0:
        return grid
    h, w = grid.shape()
    new_h = h * ky
    new_w = w * kx
    if new_h > 30 or new_w > 30:
        return grid

    new_data = [[0 for _ in range(new_w)] for _ in range(new_h)]
    for ty in range(ky):
        for tx in range(kx):
            for r in range(h):
                for c in range(w):
                    new_data[ty * h + r][tx * w + c] = grid.get(r, c)
    return Grid(new_data)


def generate_repeat_rules(
    input_grid: Grid, output_grid: Grid, *, post_process: bool = False
) -> List[SymbolicRule | CompositeRule]:
    """Return repeat rules transforming ``input_grid`` into ``output_grid``.

    When ``post_process`` is ``True`` additional rules are generated by
    applying repeat tiling first and then running colour/shape extraction on the
    intermediate result.
    """
    h1, w1 = input_grid.shape()
    h2, w2 = output_grid.shape()
    if h2 % h1 != 0 or w2 % w1 != 0:
        return []

    ky = h2 // h1
    kx = w2 // w1

    tiled = repeat_tile(input_grid, kx, ky)
    if tiled.shape() != output_grid.shape():
        return []

    diff_pixels = sum(
        1 for r in range(h2) for c in range(w2)
        if tiled.get(r, c) != output_grid.get(r, c)
    )
    diff_ratio = diff_pixels / (h2 * w2) if h2 * w2 else 0.0
    fuzz_thr = float(os.environ.get("ARC_SOLVER_REPEAT_FUZZ", MAX_REPEAT_DIFF))

    composite_map = None
    if diff_pixels and diff_ratio >= fuzz_thr:
        if ENABLE_COMPOSITE_REPEAT:
            composite_map = detect_replace_map(tiled, output_grid)
            if composite_map:
                valid = {}
                for src, tgt in composite_map.items():
                    if any(src in row for row in input_grid.data):
                        valid[src] = tgt
                composite_map = valid
            if not composite_map:
                return []
        else:
            return []

    rule = SymbolicRule(
        transformation=Transformation(
            TransformationType.REPEAT,
            params={"kx": str(kx), "ky": str(ky)},
        ),
        source=[Symbol(SymbolType.REGION, "All")],
        target=[Symbol(SymbolType.REGION, "All")],
        nature=TransformationNature.SPATIAL,
    )

    if composite_map:
        rule.meta["replace_map"] = composite_map
        rule.meta["diff_mask"] = tiled.structural_diff(output_grid)
    elif diff_pixels and diff_ratio >= fuzz_thr:
        # composite disabled; drop rule
        return []

    results: List[SymbolicRule | CompositeRule] = [rule]

    if post_process:
        try:
            from arc_solver.src.abstractions.abstractor import (
                extract_color_change_rules,
                extract_shape_based_rules,
            )

            extra_rules: List[SymbolicRule] = []
            extra_rules.extend(extract_color_change_rules(tiled, output_grid))
            extra_rules.extend(extract_shape_based_rules(tiled, output_grid))
            for er in extra_rules:
                if er.is_well_formed():
                    results.append(CompositeRule([rule, er]))
        except Exception:
            pass

    return results


__all__ = ["repeat_tile", "generate_repeat_rules"]

